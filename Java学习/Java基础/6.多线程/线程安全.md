## 线程安全

**访问共享数据时**

- 单线程式线程安全的

- 多线程有可能出现线程安全问题

### 解决线程安全问题

#### 方法1：同步代码块

将有可能出现线程安全问题的代码放入同步代码块中，只让一个线程在同步代码块中执行

**锁对象**：

- 需要创建，一般是Object对象

- 要保证多个线程使用的锁对象是同一个

**原理**：

- 线程抢到了CPU执行权，获得锁对象，就执行同步代码块中的内容

- 其他线程没有锁对象就会阻塞，直到锁对象被归还

 ```Java
synchronized(锁对象){
	可能出现线程安全问题的代码（访问了共享数据的代码）
 ```

由于锁被频繁获取、归还，降低了效率但也获得了线程安全

#### 方法2：同步方法

将有可能出现线程安全问题的代码放入同步方法中，只让一个线程在同步方法中执行

**锁对象**：

- 即Runnable实现类的对象

原理与同步代码块类似

#### 方法3：静态同步方法

效果与普通同步方法相同

锁对象：

- 不能是this
- 是本类的calss属性-->class文件对象（反射）

#### 方法4：Lock锁

Lock提供了更广泛的锁定操作，ReentrantLock为其实现类

Lock接口中的方法：

- `lock()`：获取锁

- `unlock()`：释放锁

**步骤**：

- 在类中创建ReentrantLock对象
- 在可能出现线程安全问题的代码前调用lock()，获取锁
- 在代码结束位置调用unLock()，释放锁（最好放在**finall语句块**中，无论是否有异常都会释放锁）