## 多线程

### 1、创建多线程的方法

#### 方法1：创建Thread类的子类

- 在子类中重写run方法，设置线程任务
- 并发执行多个线程，即main方法的主线程以及新创建的线程

```mermaid
graph LR 
创建Thread类的子类-->重写run方法
重写run方法-->创建子类对象
创建子类对象-->调用start方法
调用start方法-->并发执行线程
```

#### Thread类的常用方法

##### 获取线程名称

- `getName()`

返回线程名称

- `currrentThread`

返回当前正在执行的线程对象的引用

##### 改变线程名称

- `setName()`

改变线程名称，使之与参数name相同

- 带参构造方法，并调用Thread类的带参构造方法

##### 使当前线程睡眠

- `sleep(long mills)`

睡眠当前线程n毫秒

#### 方法2：实现Runnable接口

- 必须重写run方法
- 创建Thread对象，使用有参构造，以实现类对象为参数

```mermaid
graph LR 
创建Runnable接口的实现类-->重写run方法
重写run方法-->创建实现类对象和Thread对象
创建实现类对象和Thread对象-->调用start方法
调用start方法-->并发执行线程
```

```Java
DemoRunnable r1 = new DemoRunnable();
Thread t = new Thread(run)
t.start();
```

### 2、Thread类和Runnable接口的区别

#### 使用Runnable接口的好处

避免了单继承的局限性

- 继承Thread类，就不能继承其他类，比较局限
- 实现Runnable接口，还可以继承其他类、实现其他接口，可扩展

降低了程序的耦合性

- 实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离
- 重写run方法用来设置线程任务
- 创建Thread对象，调用starta方法用来开启新线程

### 3、匿名内部类创建新线程

```Java
 new Thread(new Runnable() {
            @Override
            public void run() {
				...
            }
        }).start();
```

