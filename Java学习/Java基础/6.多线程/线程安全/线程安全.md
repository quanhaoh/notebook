## 线程安全

### 竞态条件与临界区

**访问共享数据（内存、数据库、文件等）时**

- 单线程式线程安全的
- 多线程有可能出现线程安全问题，读数据不会出现线程安全问题

数据竞争：多线程访问（写）统一资源时，资源对访问顺序敏感，即会存在数据竞争，即存在线程安全问题

临界区：导致数据竞争发生的代码区即临界区，比如同时修改资源等情况

避免数据竞争：在临界区使用同步

### Java内存模型解决并发三要素的方式

#### 1、原子性

- 提供基本数据类型的6种原子操作，assign/use、load/store、read/write
- 提供锁机制：lock/unlock，反映到代码中即使用synchronized等进行同步

#### 2、可见性

- 提供volatile关键词，其修饰的变量可保证原子性
- 提供final关键字，其修饰的变量具有不变性，不会有线程安全问题
- 提供锁机制：lock/unlock，反映到代码中即使用synchronized等进行同步，执行unlock前必须刷新数据到主内存

#### 3、有序性

- 单线程操作是有序的
- 使用了happens-brefore原则
- 提供volatile关键词，通过插入内存屏障禁止指令重排优化，保证有序性

### 共享数据线程安全的程度划分

#### 1、不可变

#### 2、绝对线程安全

#### 3、相对线程安全

#### 4、线程兼容

#### 5、线程对立

### 解决线程安全问题

#### 方法1：同步代码块

将有可能出现线程安全问题的代码放入同步代码块中，只让一个线程在同步代码块中执行

**锁对象**：

- 需要创建，一般是Object对象

- 要保证多个线程使用的锁对象是同一个

**原理**：

- 线程抢到了CPU执行权，获得锁对象，就执行同步代码块中的内容

- 其他线程没有锁对象就会阻塞，直到锁对象被归还

 ```Java
synchronized(锁对象){
	可能出现线程安全问题的代码（访问了共享数据的代码）
 ```

由于锁被频繁获取、归还，降低了效率但也获得了线程安全

#### 方法2：同步方法

将有可能出现线程安全问题的代码放入同步方法中，只让一个线程在同步方法中执行

**锁对象**：

- 即Runnable实现类的对象

原理与同步代码块类似

#### 方法3：静态同步方法

效果与普通同步方法相同

锁对象：

- 不能是this
- 是本类的calss属性-->class文件对象（反射）

#### 方法4：Lock锁

Lock提供了更广泛的锁定操作，ReentrantLock为其实现类

Lock接口中的方法：

- `lock()`：获取锁

- `unlock()`：释放锁

**步骤**：

- 在类中创建ReentrantLock对象
- 在可能出现线程安全问题的代码前调用lock()，获取锁
- 在代码结束位置调用unLock()，释放锁（最好放在**finall语句块**中，无论是否有异常都会释放锁）