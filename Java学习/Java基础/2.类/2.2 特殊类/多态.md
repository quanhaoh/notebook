### 一、多态中成员变量和成员方法的使用

#### 1、成员变量的使用
**直接通过对象访问成员变量**   
编译看左，运行也看左

- 看等号左边是谁就优先用谁，没有则向上找父类
- 成员变量不能覆盖重写，所以不会向下查找子类

**间接通过成员方法访问成员变量**
- 看该方法属于谁，就优先用谁，没有则向上查找父类
- 子类若已覆盖重写，则访问子类的，否则访问父类


#### 2、成员方法的使用
编译看左，运行看右
- 编译（打代码的时候）看引用变量所在类有无该方法，没有则报错，但实际运行时若子类已覆盖，则用子类，否则向上找父类的


### 二、对象的向上和向下转型
#### 1、向上转型
正常的多态写法，就是向上转型
- 父类名称 对象名称 = new 子类名称  

可自动进行，类似于基本数据类型的自动类型转换，由小到大

弊端：无法使用子类的特有方法

#### 2、向下转型
必须保证父类对象创建时实际创建的就是该子类对象
- 子类名称 对象名称 = (子类名称)父类对象名称

类似于基本数据类型的强制类型转换

判断一个父类引用的对象原本是什么子类？

- instanceof关键词

### 三、多态的作用
可以让参数的传递有更多可能性，而不仅仅是传递固定的一种引用对象


### 四、补充

Java 引用变量有两个类型：
- 编译时类型：由声明变量时使用的类型决定
- 运行时类型：由实际赋给变量的对象决定  

当编译时类型和运行时类型不一致时（父类引用指向子类对象），即出现多态，即相同类型变量调用同一个方法时会出现不同的行为特征

> Java源文件需要经过编译成字节码文件和执行两个过程才最终实现

```java
// Person 类时是Man 类的父类
// A 在编译时是 Person 类型，在实际执行过程中是 Man 类型
Person A = new Man;
A.sex();    // sex 方法是 Man 类重写的方法
A.name();   // name 方法是继承父类的方法
A.sub();    // sub 是 Man 类独有的方法编译时会抛出异常
```

引用变量在编译阶段只能调用编译时类型所具有的方法，在执行时可以执行它执行时类型所具有的方法。

正如例子中调用 sub 方法会抛出异常，因为 sub 方法时其执行时类型的方法，在编译时（打代码时）不可以直接调用

### 引用变量的强制类型转换

若在编译时要调用执行时类型的方法，可通过强制类型转换，将编译时类型转换为执行时类型

**规则**：引用类型的强制转换只能在具有继承关系的两个类型间进行，如将父类类型转换为子类类型，子类类型转换为父类类型是可以自动转换的

**instanceof 运算符**
用于判断前面的对象是否是后面的类/子类/接口的实例，是则返回true，否则返回false

```java
if(引用类型变量 instanceof 类){
    type A = (type)A;
}
```

instanceof 前面的引用变量编译时类型必须与后面的类相同或者具有父子关系，否则会编译错误


```java
// 下面的例子会出现编译错误
String str;
if(str instanceof Math){}
```

