## volatile

volatile可以说是Java虚拟机提供的最轻量级的同步机制

volatile修饰的变量具有保证可见性的特点，且禁止指令重排优化

### 可见性

Java内存模型中每个线程拥有自己的工作内存，在处理共享变量时，作为处理器和主内存间的缓冲区，导致了可见性问题

##### 可见性问题

- 当一个线程在工作内存修改变量后，若不及时刷新到主内存中，其他线程在就会读取到主内存的脏（旧）数据

##### 保证可见性意味着共享变量的数据一致性

- 保证可以看见其他线程对共享变量的修改
- 保证其他线程可以看见自己对共享变量的修改

##### 保证可见性不等同于原子性

volatile修饰的变量在并发环境中不一定是线程安全的，

并发环境三大问题中，volatile只解决了可见性和有序性问题，并没有解决原子性问题

举个例子，volatile修饰变量的运算操作并非具有原子性（JVM规定了8种原子操作，详见Java内存模型）

```java
volatile Integer num;
// 保证原子性，只有修改数据的操作
num = 123;
// 非原子性，具有线程安全问题，在修改数据前要从主内存读取最新数据
// 假设当前线程read数据后，还没到use操作，另一个线程完成了num变量的修改并刷新到主内存中，当前线程所用数	 据便不是最新的
num++;
```

##### 如何保证可见性

每次使用共享变量，必须从主内存中读取最新数据到工作内存，且一系列操作必须是有序且全部执行，具备原子性

```mermaid
graph LR
主内存-->
read-->
load/工作内存-->
use-->处理器
```

每次修改共享变量，必须将工作内存的数据同步到主内存，且一系列原子操作必须是有序且全部执行的，具备原子性

```mermaid
graph LR
主内存-->
read-->
load/工作内存-->
use-->处理器
```

```mermaid
graph LR
处理器-->assign
assign-->工作内存/write
工作内存/write-->
store-->
主内存
```

### 禁止指令重排优化

系统处理器在执行代码过程中，会进行代码优化，即代码不一定按序执行，但会保证与顺序执行的结果相同

Java虚拟机的即时编译器中也有指令重排优化

==指令重排有可能会导致并发环境中的线程安全问题==

##### 如何禁止

volatile修饰的变量在**读操作**时与普通变量几乎没有区别

在**写操作**时会在内存中插入**内存屏障**，保证指令重排优化时其后面的指令不会先执行

### volatile修饰的变量具有原子性的运算场景

- 结果仅依赖于基本数据类型的运算
- 确保只有单一线程修改变量的值
- 变量不需要与其他的状态变量共同参与不变约束