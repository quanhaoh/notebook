## 线程安全

### 竞态条件与临界区

**访问共享数据（内存、数据库、文件等）时**

- 单线程式线程安全的
- 多线程有可能出现线程安全问题，读数据不会出现线程安全问题

数据竞争：多线程访问（写）统一资源时，资源对访问顺序敏感，即会存在数据竞争，即存在线程安全问题

临界区：导致数据竞争发生的代码区即临界区，比如同时修改资源等情况

避免数据竞争：在临界区使用同步

### Java内存模型解决并发三要素的方式

#### 1、原子性

- 提供基本数据类型的6种原子操作，assign/use、load/store、read/write
- 提供锁机制：lock/unlock，反映到代码中即使用synchronized等进行同步

#### 2、可见性

- 提供volatile关键词，其修饰的变量可保证原子性
- 提供final关键字，其修饰的变量具有不变性，不会有线程安全问题
- 提供锁机制：lock/unlock，反映到代码中即使用synchronized等进行同步，执行unlock前必须刷新数据到主内存

#### 3、有序性

- 单线程操作是有序的
- 使用了happens-brefore原则
- 提供volatile关键词，通过插入内存屏障禁止指令重排优化，保证有序性

### 共享数据线程安全的程度划分

#### 1、不可变

不可变的数据类型：

- 基本数据类型：保证线程安全
- enum类
- 其他对象：如包装类和String，使用final修饰内部状态变量来保证状态不变

#### 2、绝对线程安全

即无论在何种情况下都不会出现线程安全问题，常用的做法是在内部维护一致性的快照访问，每次次改都产生新的快照，弊端是资源消耗大

#### 3、相对线程安全

Java中所说的线程安全类即相对线程安全，对象的单次操作是线程安全的，但在并发环境中对象的连续调用仍需要进行同步，如Vector、HashTable等

#### 4、线程兼容

即对象本身不是线程安全的，需要使用同步手段，Java中大部分的对象都是线程兼容的

#### 5、线程对立

即绝对无法在并发环境中使用的