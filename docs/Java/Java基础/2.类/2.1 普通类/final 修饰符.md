final 关键字可用于修饰类、变量和方法，表示其修饰的类、变量、方法不可改变
，比如其修饰的变量不可重新赋值

## final 成员变量
final 成员变量必须在类中显式赋予初值
- 类变量：必须在静态初始化块或类变量赋值语句中指定初值
- 实例变量：必须在普通初始化块、实例变量赋值语句或构造器中指定初值

## final 局部变量
必须对其显式初始化，可先声明后赋值，但总体还是只能进行依次赋值

## final 引用类型变量
保证该引用类型变量所引用的地址保持不变，即一直引用同一个对象，但对象的内容可变

## “宏变量”效果
仅适用于 final 实例变量

当满足下列条件时，该 final 变量即相当于一个直接量
- 使用 final 修饰符修饰
- 在定义该变量时即指定初值
- 该初值可在编译时就确定下来，即在初始化时没有访问普通变量或调用方法

当 final 变量当作“宏变量”时，比如字符串常量，则会被常量池当作字符串常量管理

## final 方法
此类方法不可被子类重写，但可以重载

private 修饰的方法只是在子类中不可见，但当写一个完全一样的方法时只是在子类中重新定义了该方法

使用 final 修饰 private 方法，也可以在子类中重新定义一个于父类相同的方法，这与重写不同

## final 类
finale 类不可被继承，比如 java.lang.Math 类

## 不可变类
创建该类的实例后，实例变量不可改变，比如八个包装类以及 String 类都是不可变类

设计不可变类的原则：
- 使用 private 和 final 修饰其成员变量
- 仅为成员变量提供 getter 方法，并提供 setter 方法
- 提供带参构造器，通过传入参数来初始化类的成员变量


#### 缓存实例的不可变类
当不可变类的实例经常使用时，可通过缓存的机制实现复用，以提高效率，比如 Integer 包装类缓存了 -128~127 的数值

整数值包装类中，通过 new 是创建新的实例，保存在堆内存。通过 valueOf() 方法创建的实例视情况来保存在缓存中。
> 二者不是同一个对象

```
Integer A = new Integer(3);
Integer B = Integer.valueOf(3);
A == B  // false
```

对于其他类型的缓存实例的不可变类，大致上也是如此的用法，看具体是怎么定义其缓存的

缓存实例可以通过数组来缓存
