## LRU 缓存淘汰策略
缓存常见的有： CPU 缓存、数据库缓存、浏览器缓存

常见的缓存清理方法：
- 先进先出策略（FIFO）
- 最少使用策略
- 最近最少使用策略


## 常用链表

### 单链表
头节点：用于记录链表的基地址  
尾节点：指向一个空地址 null

### 双向链表、循环链表、双向循环链表

### 常用链表操作

###### 查找、插入、删除

- 查找的时间复杂度为 O(n)
- 单纯插入和删除的时间复杂度都为O(1)

###### 实际开发过程中执行删除操作的情况：

- 删除节点中等于某值的节点  

需要先执行遍历查找操作，再执行删除操作。故时间复杂度都为O(n)

- 删除给定指针指向的节点

对于==单链表、循环链表==而言，也需要执行遍历查找，寻找到该指针再进行删除操作，故也是0(n)

对于==双向链表、双向循环链表==，可以直接执行删除操作，时间复杂度为0(1)

###### 双向链表的优势
插入、删除操正如上所述，相对于单向链表会节约很多时间

即使是按值遍历查询，双向链表在有序链表中可以减少一半的遍历，即记录上次查询的值，比较之后决定往前还是往后查询


### 时间换空间的理念

虽然双向链表和双向循环链表需要占用更多的内存空间，但其效率相对更高，更方便，故在实际开发过程中用双向链表会更多，如 Java 的 LinkedHashMap 容器

相反，缓存机制是以空间换时间的理念